<?php

class converter_elsevier extends converter_interface{  
    
    public function __construct($document) {
        parent::__construct($document);
        /*Namespace per gli articoli elsevier*/
        $this->xpath->registerNamespace('ce', 'http://www.elsevier.com/xml/common/dtd');
        $this->xpath->registerNamespace('base','http://www.elsevier.com/xml/ja/dtd');
    }
    
    
    protected function generalizzaRiferimenti(){
                
        $list_multi_refs = $this->xpath->query('.//ce:cross-refs[starts-with(@refid,\'b\') or starts-with(@refid,\'B\')]',$this->article);
        foreach($list_multi_refs as $ref){
            $ref = $this->changeTagName($ref,"references");
            $ref_num = $ref->getAttribute("refid");
            $ref_num = split(" ",$ref_num);
            $ref->setAttribute("ref_num",(string)count($ref_num));
            $ref->nodeValue ="???".(string)count($ref_num)."]]]";
        }
        
        $list_multi_ref = $this->xpath->query('.//ce:cross-ref[starts-with(@refid,\'b\') or starts-with(@refid,\'B\')]',$this->article);
        foreach($list_multi_ref as $ref){
            $ref = $this->changeTagName($ref,"references");
            $ref->setAttribute("ref_num","1");
            $ref->nodeValue ="???1]]]";
        }
        
        if (($list_multi_ref->length == 0) && ($list_multi_refs->length == 0))
            return false;
        else
            return true;        
    }
    
    
    
    /*   Questo modulo si occupa di convertire tutti i nomi dei tag contenenti i riferimenti a "section"
     *   e i nome dei tag contenenti i titoli delle sezioni a "section-title".
     *   Nel caso in cui ci fossero dei semplici "p" o "para" dove mi aspetto di trovare le sezioni allora li
     *   aggiungo tutti ad un nuovo elemento chiamato "section" con "section-title": autogenerated_section.
     */
    protected function generalizzaSezioni(){
    
        $sections = $this->doc->getElementsByTagName('sections')->item(0);
        if (!is_null($sections)){
            $newSection = $this->doc->createElement("section");
            $title_intro = $this->doc->createElement("section-title","autogenerated_section");
            $newSection->appendChild($title_intro);
            $append_autogenerated_section = false;
            foreach($sections->childNodes as $sec){
                if(strcasecmp($sec->nodeName,"ce:section")!=0){
                   $tmp = $sec->cloneNode(true);// lo clono perchè aggiungendo direttamente $sec la lista si esauriva e quindi aggiungeva solo la prima sezione
                   $append_autogenerated_section = true;
                   $newSection->appendChild($tmp);
                }
                else{   //Aggiungo il mio prefisso ai tag "section-title"
                    $sect_title = $this->xpath->query("./ce:section-title",$sec)->item(0);
                    if(!is_null($sect_title))
                        $this->changeTagName($sect_title,"section-title");
                }
            }
            if ($append_autogenerated_section)
                $sections->appendChild($newSection);
        }        
    }
    
    
    public function createFinalDocument (){
        //trovo l'elemento principale(il nostro elemento root) cioè l'elemento "article"
        $this->article = $this->xpath->query('//base:article | //base:converted-article | //base:simple-article')->item(0);
        //$this->article = $this->xpath->query('//base:article')->item(0);
        if(is_null($this->article))
            return -1;
        
        //  procedo alla generalizzazione dei riferimenti, se non ne vengono trovati allora ritorna false.
        $continue = $this->generalizzaRiferimenti();
        if(!$continue)
            return -2;
        
        //  procedo alla generalizzazione delle sezioni
        $this->generalizzaSezioni();
        
        //   creo un nuovo documento dopo ci saranno solo gli elementi interessanti ai fini delle nostre analisi.
        $finalDoc = new DOMDocument('1.0', 'utf-8');
        $root = $finalDoc->createElementNS ( $this->prefix_uri ,'plus:root');
        $finalDoc->appendChild($root);
        
        $root = $finalDoc->firstChild;
        
        
        $abs = $this->xpath->query('./base:head//ce:abstract | ./base:simple-head//ce:abstract',$this->article);
        foreach($abs as $a){
            $tmp = $a->cloneNode(true);
            /*Aggiungo il prefisso "plus" agli elementi "abstract"*/
            $myAbs = $this->changeTagName($tmp,"abstract");
            $doc = $finalDoc->importNode($myAbs,true);
            $root->appendChild($doc);
        }
        
        /* questo NO --> $sections = $this->xpath->query('./base:body/ce:sections/ce:section',$this->article);
         * perchè non prende la sezione autogenerata che è importante ai fini delle analisi
         * poichè può contenere gli unici riferimenti disponibili.
         */
        $sections = $this->xpath->query('./base:body/ce:sections/*[local-name()=\'section\']',$this->article);
        foreach($sections as $sec){
            $tmp = $sec->cloneNode(true);
            /*Aggiungo il prefisso "plus" agli elementi "section"*/
            $mySec = $this->changeTagName($tmp,"section");
            $doc = $finalDoc->importNode($mySec,true);
            $root->appendChild($doc);
        }
        
        return $finalDoc;
    }
    
}